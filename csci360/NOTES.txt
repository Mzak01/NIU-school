3/25/24 notes
---------------

use ED for phours

EDMK finds 1st non 0 digit and puts dollar sign

problem w EDMK if value in the sending field then register 1 will not hold anything special


LA      1,OGROSS+11	<- INSURANCE FIELD.
MVC     OGROSS(15) =X'402020206B2020206B2021204B2020' <- HEX PLACEMENT FOR NUM. POINT REG 1 AT NUM 							 BEFORE 4B SO THERE WONT BE FLOATING $ IN 							 CODE

						      <- 40 IS THE FILL CHARACTER. IT SUPRESSES 							 LEADING 0'S BEFORE NUM.

						      <- 20 & 21 ARE CALLED DIGIT SELECTORS. 21 							 TURNS SIGNIFICANCE ON IN BYTE FOLLOWING
						      
  						      <- MUST HAVE AS MANY DIGIT SELECTORS AS 								 POSSIBLE SELECTORS. TAKE PACKED DECIMAL 							 FIELD AND SEE HOW MANY IT HOLDS. 6*2-1 							 BECAUSE PCALC HAS 6 DIGITS (BYTES). ALWAYS 							 HAVE ODD NUUM OF DIGIT SELECTORS
EDMK    OGROSS(15),PCALC
BCTR    1,0
MVC     0(1),C'$'








4/1/2024 NOTES
---------------

PRINT 18 DETAIL LINES FOR EACH EMPLOYEE


HEADERS IN ASSEMBLY

USE A REGISTER TO COUNT THE LINES



         LA    2,99
	 C     2,F='18'     <-- COMPARE 2 TO 18, DONT PRINT HEADERS BEFORE THE LOOP
	 BL    NOHDRS       <-- BRANCH LOAD TO NO HEADERS, EXTENDED NUEMONIC

*HEADERS GO HERE

	 AP    PAGECTR(2),PL1'1'              <--PAGE COUNTER 
	 MVC   OPAGECTR(4),=X'40202120'       <--PAGE COUNTER X
	 ED    OPAGECTR(4),PPAGECTR           <--PAGE COUNTER

	 SR    2,2	    <-- SUBTRACTS LINE COUNTER FROM ITSELF 
NOHDRS	 XPRNT              <--XPRINT THE WORK
	 LA    2,16	    <--SETS LINE COUNTER

*REGISTER ARITHEMTIC FOR SIMPLE THINGS

INCREMENT IN PACKED DECIMAL USING A LITERAL

PPAGECTR  DC    PL2'0'       <-- CAN GO UP TO 999 PAGES    MEANING 99 9C (2 BYTES)


LEARNING HOW TO DIVIDE PACKED DECIMAL

PDEPAMT  DC    PL6'0'    $99,999,999.99C
PSHRPRC  DC    PL3'0'    999.99C
PSHRAMT  DC    PL8'0'              <-- TAKE LARGEST NUMBER DIVIDED BY MAX AMOUNT OF 
					SHARES TO FIND LENGTH
PCALC	 DC    PL11'0'

				    0.01/999,999,999 99.0000   <--LARGEST NUMBER OF SHARES TO EVER 								  COMPUTE

								<-ACCOUNT FOR ENTIRE PACK DEC FIELD
								<- HAS 8 BYTES
								<- ADD 3 TO 8 FOR PCALC

LARGEST DEPOSIT AMOUNT $99,999,999.99
 *DO NOT COUNT DOLLAR SIGN IT WOULD COUNT AS A ZERO, YOU CANNOT HAVE A HALF DECIMAL

THIS WOULD BE 6 BYTES


MATH PORTION FOR DIVISION

         ZAP   PCALC(11),PDEPAMT(6)
	 SRP   PCALC(11),4,0           <--INTEGETER DIVISION, FAKING RWAL NUM DIVISION
				       <-- ROUND TO THREE
	 DP    PCALC(11),PSHRPRC(3)    <--DIVIDE PCALC BY THREE
	 SRP   PCALC(8),64-1,5         <--WHERE THE QUOTIET IS
	 SRP   PCALC(8),1,0            <-- GIVES 4 DECIMAL PLACES

-- -- -- -- -- -- -- -- -- -- --
_______________________ ________
        QUOTIENT 8      REMAIN 3

IN THE 11 BYTE FIELD THERE ARE 2 VALID PACKED DECUMAL NUMVERS




PRINTING THE NUMERIC AMOUNTS, FLOATING +,-,$ SIGNS DO THIS
	 LA    1,ODEPAMT+11,      <--INSURANCE, FIND 11 FROM DIGIT SELECTORS
				  <--INCASE PDEPAMT HOLDS ZERO, SAVES FROM SOC4/5
	 MVC   ODEPAMT(15),=X'402020206B2020206B2021204B2020'
	 EDMK  ODEPAMT(15),PDEPAMT
	 BCTR  1,0		  <--DECREMENT REGISTER 1 BY 1 
	 MVI   0(1),C'1'

ODEPAMT  DS    CL15


NO FLOATING SIGNS DO THIS

99,999,999,999.9999

	 MVC   OSHRAMT(19)=X'4020206B2020206B2020206B2021204B20202020'
	 ED    OSHRAMT(19),PSHRAMT

OSHRAMT  DC    CL19



4/8/2024 NOTES
---------------

PTGRPAY  DC    PL7'0'
OTGRPAY  DS    CL18

R1  --> FIRST BYTE OF FULLWORDS HOLDING ADDYS OF VARIAB LES BEING PASSED IN
R13 --> CALLERS REGISTER SAVE AREA, 18 REGISTER SAVE AREA
R14 --> THE ADDY OF THE INSTRUCTIONK IN THE CALLER FOLLOWING THE BRANCH TO THE 	SUBPROGRAM, AKA: WHERE TO RETURN TO WHEN SUBPROGRAM ENDS EXECUTION
R15 --> ADDY OF THE SUBPROGRAM 

*SUBROUTINE IS ETERNAL

ASIST YOU HAVE TO FAKE EXTERNAL SUBPROGRAMS

SAVE WHICH REGSISTERS YOUR SUBROUTINE IS USING

INTERNAL SUBROUTINE

CALCTAX  DS    0H
	 STM   2,5,CTSAVE
*
* STANDARD ENTRY LINKAGE GOES HERE
*



*
* STANDARD EXIT LINKAGE GOES HERE
*
         BR    14
*
         LTORG
REGSAVE  DS    18F
*
CTSAVE	 DS    3F



4/15/2024 notes
---------------

	CONVENTION FOR CALLING SUBPROGRAM

	 LA    1,BTPARMS	<--POINTS TO BTPARMS
	 L     15,=V(BUILDTBL)	<-- PULLS IN FRESH COPY OF EXECUTABLE, PUTTING IT INTO VIRTURAL CONC
	 BALR  14,15		<-- CALLS THE SUBPROGRAM


BTPARMS  DC    A(PFWHPCT)
   	 DC    A(PSWHPCT)
	 DC    A(EMPTBL)    <-- NEW
	 DC    A(PEMPCTR)

YOU HAVE TO KNOW WHICH REGISTERS POINT TO WHICH FIELD

NOW CAN CHANGE AND ACCESS VARIABLES W NO ISSUES


	 LM    2,5,0(1)   <--- POINTS TO PFWHPCT, 3 POINTS TO PSWPCT 

GOING TO INTERNAL SUBROUTINE, PASSING CONTROL LIKE JAVA
	 LA    1,BTPARMS	<-- PASSES PARMS SAME WAY
	 BAL   11,BUILDTBL	<-- CONTENTION TO CALL SUBROUTINE, DONT USE 11 IF IT IS DEDICATED AS EXTRA STORAGE
				    USE REGISTER 10 IF 11 IS EXTRA STORAGE

NO INDEX REGISTERS IN PACKED DEC INTRUCTIONS




4/17/2024 NOTES
----------------

         LA    1,PARMS
	 BAL   11,SUBRTN

	 LA    1,PARMS
	 L     15,=V(SUBPGM)  <-- CALL TO SUBPROGRAM THERE IS LINKAGE TO THE SYSTEN
				  RETURNS ADDY OF THIS PART OF MODULE INTO REGISTER 15
	 BALR  14,15	      <-- LINKS 1ST AND GOES INTO 15

IF THE EXECUTABLES GET OUT OF SYNC IT IS ABENDING CODE AND YOU CANT FIND SOURCE CODE
THIS IS WHY WE HAVE VERSION CONTROL


EVERY PIECE OF STORAGE ON THE MAINFRAME HAS A BIT OF STORAGEKEY. YOU NEED THAT TO ACESS THE STORAGE


CNPPARMS DC    A(PEMPGPAY)
	 DC    A(PEMPNPAY)*
	 DC    A(PFWHPCT)
	 DC    A(PFEDWITH)*
	 DC    A(PSWHPCT)
	 DC    A(PSTWITH)*
	

* = CALCULATE

DO NOT HARDOCDE 117 ANYWEHERE

convert emp counter to binary to count


if you declare ds d before something that needs to be on a doubleword boundary they give slack bytes


	 bct    loop2

	 is this is case 





4/29/2024 notes
----------------

the second byte is an often used byte, its the length of the immediate byte



